# 산술연산자

**❓ 자바에서 3/0.0 하면 infinity가 출력되는 이유**

**3/0 으로 나누면 ArithmeticException 산술 예외**

→ 부동 소수점 연산 규칙 때문이다. 

0으로 나누는 경우 양의 무한대가 결과로 정의되어있다. (규칙을 정해놓은 거)

<br/>

컴퓨터 프로그래밍은 A÷B를 A에 B로 몇 번 뺄 수 있느냐로 인식한다. 

0을 계속 뺀다면,  그 몫은 무한대가 되며, 나머지는 없다.

0으로 계속 빼면 무한 루프에 걸리게 되어 Nan이나 무한대로 반환한다.

<br/><br/><br/><br/><br/>

---

**❓ 300인데 왜 44가 출력되지?**

```java
class OperatorEx7 {
	public static void main(String90 args) {
		byte a = 10;
		byte b = 30;
		byte c = (byte)(a * b);
		System.out.println(c);
		// 44 출력
	}
}
```

a * b를 하게 되면 (int형)

<br/>


```java
00000000 00000000 00000001 00101100
```

(byte) a * b를 하게 되면 뒤에 있는 8바이트만 가져오게 된다.

byte 127까지만 저장 가능하다. 

<br/>

```java
00101100
```

위의 값이 44이기 때문에 44가 출력되는 것이다. 

<br/><br/><br/><br/><br/>

---

**❓ 암묵적인 형 변환**

```java
char c1 = 'a';
char c2 = (char)(c1 + 1); // ❌ c1 + 1이 int로 계산되기 때문이다. 
int c22 = c1 + 1; // ⭕
char c3 = 'a' + 1; // ⭕
```
<br/>

```java
char c1 =' a';
char c3 = 'a' + 1;
```

위 코드는 a랑 1이 상수로 간주되어서 컴파일 시에 미리 계산이 됨.

int로 계산을 하고, char 범위 내에 있으면 암묵적으로 형 변환을 수행한다.

<br/>

```java
char c2 = c1 + 1;
```

위 코드는 런타임에 연산되기 때문에 미리 계산 할 수 없다.

int로 계산을 하고, 암묵적으로 형 변환을 수행하지 않는다.

암묵적인 형 변환은 컴파일 시에만 수행된다. 

컴파일러는 코드를 분석하고 타입을 검사한 후, 가능하면 암묵적인 형 변환을 적용하여 코드를 생성해준다.

<br/><br/>


→ **컴파일 타임(실제 동작하기 전에 준비 단계)** 

소스 코드를 기계어로 변환하는 시간

문법 검사, 타입 검사, 코드 최적화 등을 수행하여 기계어 코드로 변환

에러가 있는 경우 컴파일이 실패하고, 실행 파일이 생성되지 않는다.

<br/><br/>

→ **런타임**

프로그램이 실행되는 동안의 시간을 의미 (진짜로 동작하고 있을 때)

시작되면 실행 파일이 메모리에 로드 되고, 프로그램이 사용자 또는 다른 시스템과 상호 작용하며 동작한다.

<br/><br/><br/><br/><br/>

---

**❓ float 타입의 값과 double 타입의 값을 비교하려면 어떻게 해야하는 걸까?**

double 타입의 값을 flaot타입으로 형 변환한 다음에 비교해야 한다. 

왜냐하면 double이 더 큰 정밀도를 가지고 있기 때문에,,

<br/>

```java
float f = 0.1f;
double d = 0.1;
```

f는 23비트 → 10011001100110011001101 

d는 52비트 → 10011001100110011001100110011001100110011001100110 

이 둘을 비교하면 당연히 false이기 때문에, float으로 형 변환을 한 후, 비교를 해야 한다.

<br/><br/><br/><br/><br/>

---

**❓ 문자열 리터럴, 객체 생성 방식의 차이**
<br/>
<img src="https://github.com/haeburney/StudyManage/assets/76997276/8ff1dc5a-6173-4c4a-9faf-30c008691196" width=500>
<br/>

```java
String str1 = "abc"; // 문자열 리터럴 생성법 
String str2 = new String("abc"); // new 연산자를 이용한 생성법

System.out.println(str1 == "abc") // true
System.out.println(str2 == "abc") // false
```

여기서 `abc`를 바로 넣는 것 → 얘는 문자열 리터럴임

이렇게 넣는 얘들은 **Spring Constant Pool**에 위치하게 된다. 

그래서 `str1 == “abc”`하면 **true**를 얻는다. (같은 공간을 비교하는 중이니까) 

<br/><br/>

근데 `new String(”abc”)`로 선언한다면 다른 공간에 객체가 생긴다. 

(다른 상자가 생긴 느낌이고) (**heap 영역**에 할당된다.)

new를 쓸 때마다 heap 영역에 객체가 새로 생긴다.

그래서 `str2 == “abc”`는 다른 공간에 있는 걸 비교하고 있으므로 **false**가 뜨는 것이다.

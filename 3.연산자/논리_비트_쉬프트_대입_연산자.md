# 연산자

### 논리 연산자

둘 이상의 조건을 ‘AND’나 ‘OR’으로 연결하여 하나의 식으로 표현할 수 있게 해준다.
<br/><br/>

```java
x = 6;
System.out.println(x % 2 = 0 || x % 3 = 0 && x % 6 != 0) // true
```

`x % 2 = 0` → true

`x % 3 = 0` → true

`x % 6 != 0` → false

가 된다.

<br/><br/>

그러면 

`true || true && false` 로 정리되는 것인데, `&&`는  `||`보다 우선순위가 높다.

`true && false` → false 이므로

`true || false` 가 되는데 이 연산의 값은 true이기 때문에 true로 반환된다. 

<br/><br/><br/><br/><br/>

### 효율적인 연산

| x | y | x \|\| y |
| --- | --- | --- |
| true | true | true |
| true | false | true |
| false | true | true |
| false | false | false |

<br/>

`||` 의 경우, 두 피연산자 중 어느 한 쪽만 ‘참’이어도 전체 연산결과가 ‘참’이므로 좌측 피연산자가 ‘true’이면, 우측 피연산자의 값은 평가하지 않는다. 

`&&` 연산자도 마찬가지로, 어느 한쪽만 ‘false’이어도 전체 연산결과가 ‘거짓’이므로 좌측 피연산자가 거짓이면, 우측 피연산자는 평가하지 않는다.

그래서 같은 조건식이라도 피연산자의 위치에 따라서 연산속도가 달라질 수 이는 것이다.

`||` 연산의 경우에는 연산결과가 ‘참’일 확률이 높은 피연산자를 연산자의 왼쪽에 놓아 더 빠른 연산결과를 얻을 수 있다. 

<br/><br/>

```java
('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z')
```

소문자를 왼쪽에 쓴 이유는 사용자로부터 문자 ch를 입력받을 때, 사용자가 대문자보다 소문자를 입력할 확률이 높다고 판단했기 때문이다. 

<br/><br/>

```java
public class Test {
    public static void main(String[] args){
        int a=5;
        int b=0;

        System.out.printf("a=%d, b=%d%n",a,b);
        // a=5, b=0
        
        System.out.printf("a!=0 || ++b !=0 => %b%n",(a!=0 || ++b !=0));
        // a!=0 || ++b !=0 => true
        
        System.out.printf("a=%d, b=%d%n",a,b);
        // a=5, b=0
        
        System.out.printf("a==0 || ++b !=0 => %b%n",(a==0 && ++b !=0));
        // a==0 || ++b !=0 => false
        
        System.out.printf("a=%d, b=%d%n",a,b);
				//  a=5, b=0
    }
}

```

두 줄 모두 `a!=0` 과 `a==0` 에서 true or false를 반환하기 때문에 ++b는 연산이 되지 않는다.

그래서 b를 출력해도 값이 0인걸 알 수 있다. 

<br/><br/><br/><br/><br/>

### 비트 전환 연산자 ~

| x | ~x |
| --- | --- |
| 1 | 0 |
| 0 | 1 |

00001010 을 비트 전환하면

11110101 로 바뀐다. 

11110101은 -11로, 이 값은 10의 ‘1의 보수’이다. 

<br/><br/><br/><br/><br/>

### 쉬프트 연산자 << >>

| 8 | 000010000 |
| --- | --- |
| 8>>0 (8>>32) | 00001000 |
| 8>>1 | 00000100 |
| 8>>2 (8>>34) | 00000010 |

<br/>

`x << n`

여기서 n의 값이 자료형의 bit수 보다 크면, 자료형의 bit수로 나눈 나머지만큼만 이동한다.

8 >> 32 이면 32%8 = 0 만큼 이동

8 >> 34 이면 34%8 = 2 만큼 이동 한다는 뜻이다.

<br/><br/>

**❓쉬프트 연산자를 사용하는 이유는?**

→ **속도** 때문이다. 

`8 / 4` 와 `8 >> 2` 의 결과는 같다.

하지만 >>로 연산을 하는 게 더 빠르다.

<br/><br/>

**❓왜 더 빠른건데?**

'8/4'는 정수 나눗셈 연산으로, CPU의 **정수 연산 유닛(ALU)** 에서 수행되고,

반면에 '8>>2'는 비트 이동 연산으로, CPU의 **비트 이동 유닛(Shift Unit)** 에서 수행된다. 

비트 이동 연산은 정수 나눗셈 연산보다 더 적은 수의 연산을 수행하기 때문에 더 빠르다.

<br/><br/>

**❓얼마나 더 빠른건데?**

일반적으로 비트 이동 연산은 정수 나눗셈 연산보다 **2배** 이상 빠른 것으로 알려져 있다.

(하지만 연산 속도는 CPU의 종류, 성능, 운영체제 등에 따라 다르기 때문에 정확한 속도 차이를 측정하기는 어렵다.)

<br/><br/>

**그러나**

그렇지만 곱셈 또는 나눗셈 연산자보다는 가독성이 떨어지기 때문에, 빠른 실행속도가 요구되어지는 곳에서만 쉬프트 연산자를 사용하는 것이 좋다. 

<br/><br/><br/><br/><br/>

### 대입 연산자 =

```java
int number;
number = 4;
```

여기서 `number` 는 **lvalue**(left value) 이고,

`4` 는 **rvalue**(right value)이다.

**rvalue**는 변수뿐만 아니라 식이나 상수 등이 모두 가능한 반면,

**lvalue**는 반드시 변수처럼 값을 변경할 수 있는 것이어야 한다.

그래서 리터럴이나 상수같이 값을 저장할 수 없는 것들은 lvalue가 될 수 없다.
